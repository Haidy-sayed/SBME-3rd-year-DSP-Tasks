# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Task4GUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
#from pandas.io.parsers import ParserError
import logging
from tkinter.constants import S
import matplotlib as mpl
from matplotlib.backends.backend_agg import FigureCanvasAgg
from PyQt5.QtWidgets import QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QDesktopWidget

from PyQt5.QtWidgets import * 
from time import sleep
import time
from PyQt5 import QtCore, QtGui, QtWidgets
import numpy as np
from matplotlib.figure import Figure
from numpy.core.fromnumeric import reshape
import pyqtgraph.exporters

from PyQt5 import QtCore, QtGui, QtWidgets
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QApplication, QColorDialog, QFileDialog, QFrame, QWidget, QInputDialog, QLineEdit,QComboBox
import os
import numpy as np
from PyQt5.QtWidgets import QMessageBox
import sys 
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QColorDialog
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QColor ,QKeySequence
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from pyqtgraph.graphicsItems.ScatterPlotItem import Symbols
from pyqtgraph.graphicsItems.ImageItem import ImageItem
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import cv2
import io
from numpy.fft import fft, fftfreq, ifft
from scipy.fftpack import fft, ifft
from scipy import signal
import cmath
from scipy.io.wavfile import write
from pyqtgraph import PlotWidget
from PyQt5 import QtCore, QtGui, QtWidgets
import pyqtgraph.exporters
from fpdf import FPDF
import statistics
from pyqtgraph import PlotWidget
import pyqtgraph
from pyqtgraph import *
import pyqtgraph as pg
from pyqtgraph import PlotWidget, PlotItem
#from matplotlib.pyplot import draw
import matplotlib.pyplot as plt
from scipy.fftpack import fft, ifft
import pandas as pd
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QApplication, QColorDialog, QFileDialog, QFrame, QWidget, QInputDialog, QLineEdit,QComboBox
import os
import numpy as np
from PyQt5.QtWidgets import QMessageBox
import sys 
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QColorDialog
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QColor
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from pyqtgraph.graphicsItems.ScatterPlotItem import Symbols
from pyqtgraph.graphicsItems.ImageItem import ImageItem
from matplotlib.figure import Figure
import io
from numpy.fft import fft, fftfreq, ifft
from scipy.fftpack import fft, ifft
from scipy import signal
import cmath
import cv2
pg.setConfigOption('background', 'w')


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1033, 685)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayoutForWholeWindow = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayoutForWholeWindow.setObjectName("horizontalLayout")
        self.FittingOptionsContianer = QtWidgets.QWidget(self.centralwidget)
        self.FittingOptionsContianer.setMaximumSize(QtCore.QSize(150, 16777215))
        self.FittingOptionsContianer.setObjectName("FittingOptionsContianer")
        self.verticalLayoutFittingOptionsContainer = QtWidgets.QVBoxLayout(self.FittingOptionsContianer)
        self.verticalLayoutFittingOptionsContainer.setObjectName("verticalLayout_2")
        self.FittingOptionsLabel = QtWidgets.QLabel(self.FittingOptionsContianer)
        self.FittingOptionsLabel.setMaximumSize(QtCore.QSize(16777215, 15))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.FittingOptionsLabel.setFont(font)
        self.FittingOptionsLabel.setObjectName("FittingOptionsLabel")
        self.verticalLayoutFittingOptionsContainer.addWidget(self.FittingOptionsLabel)
        self.toolBox = QtWidgets.QToolBox(self.FittingOptionsContianer)
        self.toolBox.setObjectName("toolBox")
        self.page1ForControls = QtWidgets.QWidget()
        self.page1ForControls.setGeometry(QtCore.QRect(0, 0, 132, 448))
        self.page1ForControls.setObjectName("Num Chunks Options")
        self.label_3ForExtrapolationPercentage = QtWidgets.QLabel(self.page1ForControls)
        self.label_3ForExtrapolationPercentage.setGeometry(QtCore.QRect(0, 100, 121, 20))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label_3ForExtrapolationPercentage.setFont(font)
        self.label_3ForExtrapolationPercentage.setObjectName("label_3")
        self.ExtrapolationEfficiencySlider = QtWidgets.QSlider(self.page1ForControls)
        self.ExtrapolationEfficiencySlider.setGeometry(QtCore.QRect(50, 140, 22, 231))
        font = QtGui.QFont()
        font.setBold(False)
        font.setWeight(50)
        self.ExtrapolationEfficiencySlider.setFont(font)
        self.ExtrapolationEfficiencySlider.setMinimum(1)
        self.ExtrapolationEfficiencySlider.setMaximum(10)
        self.ExtrapolationEfficiencySlider.setSingleStep(1)
        self.ExtrapolationEfficiencySlider.setPageStep(1)
        self.ExtrapolationEfficiencySlider.setSliderPosition(10)
        self.ExtrapolationEfficiencySlider.setTracking(True)
        self.ExtrapolationEfficiencySlider.setOrientation(QtCore.Qt.Vertical)
        self.ExtrapolationEfficiencySlider.setInvertedAppearance(False)
        self.ExtrapolationEfficiencySlider.setInvertedControls(False)
        self.ExtrapolationEfficiencySlider.setTickPosition(QtWidgets.QSlider.TicksAbove)
        self.ExtrapolationEfficiencySlider.setTickInterval(0)
        self.ExtrapolationEfficiencySlider.setObjectName("ExtrapolationEfficiencySlider")
        self.label_4ForExtrapolation100 = QtWidgets.QLabel(self.page1ForControls)
        self.label_4ForExtrapolation100.setGeometry(QtCore.QRect(0, 135, 41, 21))
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.label_4ForExtrapolation100.setFont(font)
        self.label_4ForExtrapolation100.setObjectName("label_4")
        self.label_5ForExtrapolation10 = QtWidgets.QLabel(self.page1ForControls)
        self.label_5ForExtrapolation10.setGeometry(QtCore.QRect(10, 355, 31, 21))
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.label_5ForExtrapolation10.setFont(font)
        self.label_5ForExtrapolation10.setObjectName("label_5")
        self.widget = QtWidgets.QWidget(self.page1ForControls)
        self.widget.setGeometry(QtCore.QRect(0, 0, 131, 89))
        self.widget.setObjectName("widget")
        self.verticalLayoutNumChunksOptions = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayoutNumChunksOptions.setContentsMargins(0, 0, 0, 0)
        self.verticalLayoutNumChunksOptions.setObjectName("verticalLayout_3")
        self.NumChunksLabel = QtWidgets.QLabel(self.widget)
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.NumChunksLabel.setFont(font)
        self.NumChunksLabel.setObjectName("NumChunksLabel")
        self.verticalLayoutNumChunksOptions.addWidget(self.NumChunksLabel)
        self.OneChunkRadioButton = QtWidgets.QRadioButton(self.widget)
        self.OneChunkRadioButton.setObjectName("OneChunkRadioButton")
        self.verticalLayoutNumChunksOptions.addWidget(self.OneChunkRadioButton)
        self.MultipleChunksRadioButton = QtWidgets.QRadioButton(self.widget)
        self.MultipleChunksRadioButton.setObjectName("MultipleChunksRadioButton")
        self.verticalLayoutNumChunksOptions.addWidget(self.MultipleChunksRadioButton)
        self.NumberChunksSpinBox = QtWidgets.QSpinBox(self.widget)
        self.NumberChunksSpinBox.setMaximum(999)
        self.NumberChunksSpinBox.setObjectName("NumberChunksSpinBox")
        self.verticalLayoutNumChunksOptions.addWidget(self.NumberChunksSpinBox)
        self.toolBox.addItem(self.page1ForControls, "")
        self.page2ForControls = QtWidgets.QWidget()
        self.page2ForControls.setGeometry(QtCore.QRect(0, 0, 132, 448))
        self.page2ForControls.setObjectName("page_2")
        self.OrderOfInterpolationLabel = QtWidgets.QLabel(self.page2ForControls)
        self.OrderOfInterpolationLabel.setGeometry(QtCore.QRect(0, 180, 131, 16))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.OrderOfInterpolationLabel.setFont(font)
        self.OrderOfInterpolationLabel.setObjectName("OrderOfInterpolationLabel")
        self.InterPolationOrderSlider = QtWidgets.QSlider(self.page2ForControls)
        self.InterPolationOrderSlider.setGeometry(QtCore.QRect(80, 210, 22, 171))
        self.InterPolationOrderSlider.setMaximum(50)
        self.InterPolationOrderSlider.setMinimum(2)

     #   self.InterPolationOrderSlider.setPageStep(9)
        self.InterPolationOrderSlider.setValue(1)
        self.InterPolationOrderSlider.setOrientation(QtCore.Qt.Vertical)
        self.InterPolationOrderSlider.setTickPosition(QtWidgets.QSlider.TicksAbove)
        self.InterPolationOrderSlider.setObjectName("InterPolationOrderSlider")
        
        
        self.order1Label = QtWidgets.QLabel(self.page2ForControls)
        self.order1Label.setGeometry(QtCore.QRect(10, 370, 47, 13))
        self.order1Label.setObjectName("order1Label")
        self.order10Label = QtWidgets.QLabel(self.page2ForControls)
        self.order10Label.setGeometry(QtCore.QRect(0, 210, 61, 16))
        self.order10Label.setObjectName("order10Label")
        self.lcdOrder = QtWidgets.QLCDNumber(self.page2ForControls)
        self.lcdOrder.setGeometry(QtCore.QRect(10, 400, 41, 31))
        self.lcdOrder.setObjectName("lcdOrder")
        self.LCDOrderLabel = QtWidgets.QLabel(self.page2ForControls)
        self.LCDOrderLabel.setGeometry(QtCore.QRect(70, 405, 61, 21))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.LCDOrderLabel.setFont(font)
        self.LCDOrderLabel.setObjectName("LCDOrderLabel")
        self.widget1 = QtWidgets.QWidget(self.page2ForControls)
        self.widget1.setGeometry(QtCore.QRect(0, 10, 121, 42))
        self.widget1.setObjectName("widget1")
        self.verticalLayoutNumChunksSpinContainer = QtWidgets.QVBoxLayout(self.widget1)
        self.verticalLayoutNumChunksSpinContainer.setContentsMargins(0, 0, 0, 0)
        self.verticalLayoutNumChunksSpinContainer.setObjectName("verticalLayout_6")
        self.ChunkNumberSpinLabel = QtWidgets.QLabel(self.widget1)
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.ChunkNumberSpinLabel.setFont(font)
        self.ChunkNumberSpinLabel.setObjectName("ChunkNumberSpinLabel")
        self.verticalLayoutNumChunksSpinContainer.addWidget(self.ChunkNumberSpinLabel)
        self.ChunkNumberComboBox = QtWidgets.QComboBox(self.widget1)
        self.ChunkNumberComboBox.setObjectName("ChunkNumberComboBox")
        self.verticalLayoutNumChunksSpinContainer.addWidget(self.ChunkNumberComboBox)
        self.YaxisChoiceWidget = QtWidgets.QWidget(self.page2ForControls)
        self.YaxisChoiceWidget.setGeometry(QtCore.QRect(0, 60, 122, 108))
        self.YaxisChoiceWidget.setObjectName("YaxisChoiceWidget")
        self.verticalLayoutTypeOfInterPolationContainer = QtWidgets.QVBoxLayout(self.YaxisChoiceWidget)
        self.verticalLayoutTypeOfInterPolationContainer.setContentsMargins(0, 0, 0, 0)
        self.verticalLayoutTypeOfInterPolationContainer.setObjectName("verticalLayout_4")
        self.TypeOfInterpolationLabel = QtWidgets.QLabel(self.YaxisChoiceWidget)
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.TypeOfInterpolationLabel.setFont(font)
        self.TypeOfInterpolationLabel.setObjectName("label_2")
        self.verticalLayoutTypeOfInterPolationContainer.addWidget(self.TypeOfInterpolationLabel)
        self.LinearInterpRadioBtn = QtWidgets.QRadioButton(self.YaxisChoiceWidget)
        self.LinearInterpRadioBtn.setObjectName("LinearInterpRadioBtn")
        self.verticalLayoutTypeOfInterPolationContainer.addWidget(self.LinearInterpRadioBtn)
        self.PolynomialInterpRadioBtn = QtWidgets.QRadioButton(self.YaxisChoiceWidget)
        self.PolynomialInterpRadioBtn.setObjectName("PolynomialInterpRadioBtn")
        self.verticalLayoutTypeOfInterPolationContainer.addWidget(self.PolynomialInterpRadioBtn)
        
        self.toolBox.addItem(self.page2ForControls, "")
        self.verticalLayoutFittingOptionsContainer.addWidget(self.toolBox)
        self.horizontalLayoutForWholeWindow.addWidget(self.FittingOptionsContianer)
        self.lineBetweenMathAreaAndGraphArea = QtWidgets.QFrame(self.centralwidget)
        self.lineBetweenMathAreaAndGraphArea.setFrameShape(QtWidgets.QFrame.VLine)
        self.lineBetweenMathAreaAndGraphArea.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.lineBetweenMathAreaAndGraphArea.setObjectName("lineBetweenMathAreaAndGraphArea")
        self.horizontalLayoutForWholeWindow.addWidget(self.lineBetweenMathAreaAndGraphArea)
        self.DataContainer = QtWidgets.QWidget(self.centralwidget)
        self.DataContainer.setMinimumSize(QtCore.QSize(100, 0))
        self.DataContainer.setObjectName("DataContainer")
        self.verticalLayoutForMaths = QtWidgets.QVBoxLayout(self.DataContainer)
        self.verticalLayoutForMaths.setObjectName("verticalLayoutForMaths")
        self.MathematicsLabel = QtWidgets.QLabel(self.DataContainer)
        self.MathematicsLabel.setMaximumSize(QtCore.QSize(16777215, 15))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.MathematicsLabel.setFont(font)
        self.MathematicsLabel.setObjectName("MathematicsLabel")
        self.verticalLayoutForMaths.addWidget(self.MathematicsLabel)
        
        
        self.MathDisplayArea = QTableWidget(self.DataContainer)
        self.MathDisplayArea.setObjectName("MathDisplayArea")
        self.MathDisplayArea.setMaximumSize(QtCore.QSize(16777215, 270))
        
        self.MathDisplayArea.setColumnCount(2)  
        self.MathDisplayArea.setHorizontalHeaderLabels(["Equation","Error"])	
        self.MathDisplayArea.resizeColumnsToContents()
        self.MathDisplayArea.verticalHeader().setDefaultSectionSize(30)
        
        self.verticalLayoutForMaths.addWidget(self.MathDisplayArea)
        self.ErrorMappingLabel_2 = QtWidgets.QLabel(self.DataContainer)
        self.ErrorMappingLabel_2.setMaximumSize(QtCore.QSize(16777215, 15))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.ErrorMappingLabel_2.setFont(font)
        self.ErrorMappingLabel_2.setObjectName("ErrorMappingLabel_2")
        self.verticalLayoutForMaths.addWidget(self.ErrorMappingLabel_2)
        self.ErrorMappingCalcContainerWidget = QtWidgets.QWidget(self.DataContainer)
        self.ErrorMappingCalcContainerWidget.setObjectName("ErrorMappingCalcContainerWidget")
        self.ErrorMappingButton = QtWidgets.QPushButton(self.ErrorMappingCalcContainerWidget)
        self.ErrorMappingButton.setGeometry(QtCore.QRect(10, 240, 75, 23))
        self.ErrorMappingButton.setObjectName("ErrorMappingButton")
        self.ErrorMappingProgressBar = QtWidgets.QProgressBar(self.ErrorMappingCalcContainerWidget)
        self.ErrorMappingProgressBar.setGeometry(QtCore.QRect(110, 240, 171, 23))
        self.ErrorMappingProgressBar.setProperty("value", 0)
        self.ErrorMappingProgressBar.setTextVisible(True)
        self.ErrorMappingProgressBar.setOrientation(QtCore.Qt.Horizontal)
        self.ErrorMappingProgressBar.setInvertedAppearance(False)
        self.ErrorMappingProgressBar.setObjectName("ErrorMappingProgressBar")
        self.XaxisLabel = QtWidgets.QLabel(self.ErrorMappingCalcContainerWidget)
        self.XaxisLabel.setGeometry(QtCore.QRect(0, 90, 47, 16))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.XaxisLabel.setFont(font)
        self.XaxisLabel.setObjectName("XaxisLabel")
        self.YaxisLabel = QtWidgets.QLabel(self.ErrorMappingCalcContainerWidget)
        self.YaxisLabel.setGeometry(QtCore.QRect(0, 120, 47, 16))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.YaxisLabel.setFont(font)
        self.YaxisLabel.setObjectName("YaxisLabel")
        self.ErrorMAooingAreaidget = QtWidgets.QWidget(self.ErrorMappingCalcContainerWidget)
        self.ErrorMAooingAreaidget.setGeometry(QtCore.QRect(70, 80, 221, 31))
        self.ErrorMAooingAreaidget.setObjectName("ErrorMAooingAreaidget")
        self.xAxisNumChunksRadioBtn = QtWidgets.QRadioButton(self.ErrorMAooingAreaidget)
        self.xAxisNumChunksRadioBtn.setGeometry(QtCore.QRect(0, 10, 82, 17))
        self.xAxisNumChunksRadioBtn.setObjectName("xAxisNumChunksRadioBtn")
        self.xAxisInterpolationRadioBtn = QtWidgets.QRadioButton(self.ErrorMAooingAreaidget)
        self.xAxisInterpolationRadioBtn.setGeometry(QtCore.QRect(90, 10, 151, 17))
        self.xAxisInterpolationRadioBtn.setObjectName("xAxisInterpolationRadioBtn")
        self.YaxisChoiceWidget = QtWidgets.QWidget(self.ErrorMappingCalcContainerWidget)
        self.YaxisChoiceWidget.setGeometry(QtCore.QRect(70, 110, 221, 31))
        self.YaxisChoiceWidget.setObjectName("YaxisChoiceWidget")
        self.yAxisNumChunksRadioBtn = QtWidgets.QRadioButton(self.YaxisChoiceWidget)
        self.yAxisNumChunksRadioBtn.setGeometry(QtCore.QRect(0, 10, 82, 17))
        self.yAxisNumChunksRadioBtn.setObjectName("yAxisNumChunksRadioBtn")
        self.yAxisInterpolationRadioBtn = QtWidgets.QRadioButton(self.YaxisChoiceWidget)
        self.yAxisInterpolationRadioBtn.setGeometry(QtCore.QRect(90, 10, 151, 17))
        self.yAxisInterpolationRadioBtn.setObjectName("yAxisInterpolationRadioBtn")
        self.ChooseChunkLabel = QtWidgets.QLabel(self.ErrorMappingCalcContainerWidget)
        self.ChooseChunkLabel.setGeometry(QtCore.QRect(0, 0, 91, 16))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.ChooseChunkLabel.setFont(font)
        self.ChooseChunkLabel.setObjectName("label_10")
        self.ChooseOrderLabel = QtWidgets.QLabel(self.ErrorMappingCalcContainerWidget)
        self.ChooseOrderLabel.setGeometry(QtCore.QRect(0, 60, 91, 16))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.ChooseOrderLabel.setFont(font)
        self.ChooseOrderLabel.setObjectName("label_11")
        self.ChooseChunkComboBox = QtWidgets.QComboBox(self.ErrorMappingCalcContainerWidget)
        self.ChooseChunkComboBox.setGeometry(QtCore.QRect(140, 0, 131, 22))
        self.ChooseChunkComboBox.setObjectName("ChooseChunkComboBox")
        self.ChooseOrderComboBox = QtWidgets.QComboBox(self.ErrorMappingCalcContainerWidget)
        self.ChooseOrderComboBox.setGeometry(QtCore.QRect(140, 60, 131, 22))
        self.ChooseOrderComboBox.setObjectName("ChooseOrderComboBox")
        self.ChooseOrderComboBox.setMaxCount(999)
        self.ChooseOverLapComboBox = QComboBox(self.ErrorMappingCalcContainerWidget)
        self.ChooseOverLapComboBox.setGeometry(QRect(140, 30, 131, 22))
        self.ChooseOverLapComboBox.setObjectName("ChooseOverLapComboBox")
        self.ErrorMAppingOrderOfInterpolationLabel = QLabel(self.ErrorMappingCalcContainerWidget)
        self.ErrorMAppingOrderOfInterpolationLabel.setObjectName(u"ErrorMAppingOrderOfInterpolationLabel")
        self.ErrorMAppingOrderOfInterpolationLabel.setGeometry(QRect(0, 30, 131, 16))
        font5 = QFont()
        font5.setPointSize(9)
        font5.setBold(True)
        font5.setWeight(75)
        self.ErrorMAppingOrderOfInterpolationLabel.setFont(font5)

        self.xAxisOverLapRadioBtn = QRadioButton(self.ErrorMappingCalcContainerWidget)
        self.xAxisOverLapRadioBtn.setObjectName("xAxisOverLapRadioBtn")
        self.xAxisOverLapRadioBtn.setGeometry(QRect(300, 90, 121, 17))
        self.yAxisOverLapRadioBtn = QRadioButton(self.ErrorMappingCalcContainerWidget)
        self.yAxisOverLapRadioBtn.setObjectName("yAxisOverLapRadioBtn")
        self.yAxisOverLapRadioBtn.setGeometry(QRect(300, 120, 121, 17))

        self.verticalLayoutForMaths.addWidget(self.ErrorMappingCalcContainerWidget)
        self.horizontalLayoutForWholeWindow.addWidget(self.DataContainer)
        self.line = QtWidgets.QFrame(self.centralwidget)
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.horizontalLayoutForWholeWindow.addWidget(self.line)
        self.GraphingContainer = QtWidgets.QWidget(self.centralwidget)
        self.GraphingContainer.setMinimumSize(QtCore.QSize(0, 0))
        self.GraphingContainer.setMaximumSize(QtCore.QSize(600, 16777215))
        self.GraphingContainer.setObjectName("GraphingContainer")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.GraphingContainer)
        self.verticalLayout.setObjectName("verticalLayout")
        self.CurveFittingLabel = QtWidgets.QLabel(self.GraphingContainer)
        self.CurveFittingLabel.setMaximumSize(QtCore.QSize(16777215, 15))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(11)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        font.setStrikeOut(False)
        font.setKerning(True)
        self.CurveFittingLabel.setFont(font)
        self.CurveFittingLabel.setObjectName("CurveFittingLabel")
        self.verticalLayout.addWidget(self.CurveFittingLabel)
        self.CurveFittingGraph = pyqtgraph.PlotWidget(self.GraphingContainer)
        self.CurveFittingGraph.setObjectName("CurveFittingGraph")
        self.verticalLayout.addWidget(self.CurveFittingGraph)
        
        self.lineBetweenGraphAndErrorAreas = QtWidgets.QFrame(self.GraphingContainer)
        self.lineBetweenGraphAndErrorAreas.setFrameShape(QtWidgets.QFrame.HLine)
        self.lineBetweenGraphAndErrorAreas.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.lineBetweenGraphAndErrorAreas.setObjectName("lineBetweenGraphAndErrorAreas")
        self.verticalLayout.addWidget(self.lineBetweenGraphAndErrorAreas)
        self.ErrorMappingLabel = QtWidgets.QLabel(self.GraphingContainer)
        self.ErrorMappingLabel.setMaximumSize(QtCore.QSize(16777215, 15))
        font = QtGui.QFont()
        font.setFamily("Leelawadee")
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.ErrorMappingLabel.setFont(font)
        self.ErrorMappingLabel.setObjectName("ErrorMappingLabel")
        self.verticalLayout.addWidget(self.ErrorMappingLabel)
        self.ErrorMappingGraph = QtWidgets.QLabel(self.GraphingContainer)
        self.ErrorMappingGraph.setObjectName("ErrorMappingGraph")
        self.verticalLayout.addWidget(self.ErrorMappingGraph)
        self.horizontalLayoutForWholeWindow.addWidget(self.GraphingContainer)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuGraphs_Options = QtWidgets.QMenu(self.menubar)
        self.menuGraphs_Options.setObjectName("menuGraphs_Options")
        self.menuCurve_Fitting = QtWidgets.QMenu(self.menuGraphs_Options)
        self.menuCurve_Fitting.setObjectName("menuCurve_Fitting")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen_File = QtWidgets.QAction(MainWindow)
        self.actionOpen_File.setObjectName("actionOpen_File")
        self.actionSave_Curve_fitting_IMG = QtWidgets.QAction(MainWindow)
        self.actionSave_Curve_fitting_IMG.setObjectName("actionSave_Curve_fitting_IMG")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.actionCurveZoom_in = QtWidgets.QAction(MainWindow)
        self.actionCurveZoom_in.setObjectName("actionCurveZoom_in")
        self.actioncurveZoom_out = QtWidgets.QAction(MainWindow)
        self.actioncurveZoom_out.setObjectName("actioncurveZoom_out")
        self.actionRun_EM = QtWidgets.QAction(MainWindow)
        self.actionRun_EM.setObjectName("actionRun_EM")
        self.actionErrorZoom_in_2 = QtWidgets.QAction(MainWindow)
        self.actionErrorZoom_in_2.setObjectName("actionErrorZoom_in_2")
        self.actionErrorZoom_out_2 = QtWidgets.QAction(MainWindow)
        self.actionErrorZoom_out_2.setObjectName("actionErrorZoom_out_2")
        self.menuFile.addAction(self.actionOpen_File)
        self.menuFile.addAction(self.actionSave_Curve_fitting_IMG)
        self.menuFile.addAction(self.actionExit)
        self.menuCurve_Fitting.addAction(self.actionCurveZoom_in)
        self.menuCurve_Fitting.addAction(self.actioncurveZoom_out)
        self.menuGraphs_Options.addAction(self.menuCurve_Fitting.menuAction())
        self.menuGraphs_Options.addSeparator()
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuGraphs_Options.menuAction())

        self.retranslateUi(MainWindow)
        self.toolBox.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.FittingOptionsLabel.setText(_translate("MainWindow", "Fitting Options"))
        self.label_3ForExtrapolationPercentage.setText(_translate("MainWindow", "Extrapolation %"))
        self.label_4ForExtrapolation100.setText(_translate("MainWindow", "100%"))
        self.label_5ForExtrapolation10.setText(_translate("MainWindow", "10%"))
        self.NumChunksLabel.setText(_translate("MainWindow", "Num Chunks"))
        self.OneChunkRadioButton.setText(_translate("MainWindow", "One Chunk"))
        self.MultipleChunksRadioButton.setText(_translate("MainWindow", "Multiple Chunks"))
        self.toolBox.setItemText(self.toolBox.indexOf(self.page1ForControls), _translate("MainWindow", "Page 1"))
        self.OrderOfInterpolationLabel.setText(_translate("MainWindow", "Order of Interpolation"))
        self.order1Label.setText(_translate("MainWindow", "2nd order"))
        self.order10Label.setText(_translate("MainWindow", "50th order"))
        self.LCDOrderLabel.setText(_translate("MainWindow", "Order"))
        self.ChunkNumberSpinLabel.setText(_translate("MainWindow", "Chunk Number"))
        self.TypeOfInterpolationLabel.setText(_translate("MainWindow", "Type of Interpolation"))
        self.LinearInterpRadioBtn.setText(_translate("MainWindow", "Linear"))
        self.PolynomialInterpRadioBtn.setText(_translate("MainWindow", "Polynomial"))
        
        self.toolBox.setItemText(self.toolBox.indexOf(self.page2ForControls), _translate("MainWindow", "Page 2"))
        self.MathematicsLabel.setText(_translate("MainWindow", "Mathematics"))
        self.ErrorMappingLabel_2.setText(_translate("MainWindow", "Error Mapping "))
        self.ErrorMappingButton.setText(_translate("MainWindow", "Run EM"))
        self.XaxisLabel.setText(_translate("MainWindow", "X-axis"))
        self.YaxisLabel.setText(_translate("MainWindow", "Y-axis"))
        self.xAxisNumChunksRadioBtn.setText(_translate("MainWindow", "Num Chunks"))
        self.xAxisInterpolationRadioBtn.setText(_translate("MainWindow", "Interpolation order"))
        self.yAxisNumChunksRadioBtn.setText(_translate("MainWindow", "Num Chunks"))
        self.yAxisInterpolationRadioBtn.setText(_translate("MainWindow", "Interpolation order"))
        self.xAxisOverLapRadioBtn.setText(QCoreApplication.translate("MainWindow", "OverLab"))
        self.yAxisOverLapRadioBtn.setText(QCoreApplication.translate("MainWindow", "OverLab"))
        self.ChooseChunkLabel.setText(_translate("MainWindow", "Choose Chunk"))
        self.ChooseOrderLabel.setText(_translate("MainWindow", "Choose Order"))
        self.ErrorMAppingOrderOfInterpolationLabel.setText(QCoreApplication.translate("MainWindow", "Choose OverLab"))
        self.CurveFittingLabel.setText(_translate("MainWindow", "Curve Fitting Area"))
        self.ErrorMappingLabel.setText(_translate("MainWindow", "Error Mapping Area"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuGraphs_Options.setTitle(_translate("MainWindow", "Graphs Options"))
        self.menuCurve_Fitting.setTitle(_translate("MainWindow", "Curve Fitting"))
        self.actionOpen_File.setText(_translate("MainWindow", "Open File"))
        self.actionOpen_File.setShortcut(_translate("MainWindow", "Ctrl+O"))
        self.actionSave_Curve_fitting_IMG.setText(_translate("MainWindow", "Save Curve fitting IMG"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))
        self.actionExit.setShortcut(_translate("MainWindow", "esc"))
        self.actionCurveZoom_in.setText(_translate("MainWindow", "Zoom in"))
        self.actionCurveZoom_in.setShortcut(_translate("MainWindow", "+"))
        self.actioncurveZoom_out.setText(_translate("MainWindow", "Zoom out"))
        self.actioncurveZoom_out.setShortcut(_translate("MainWindow", "-"))
        self.actionRun_EM.setText(_translate("MainWindow", "Run EM"))
        self.actionRun_EM.setShortcut(_translate("MainWindow", "Ctrl+E"))
        self.actionErrorZoom_in_2.setText(_translate("MainWindow", "Zoom in"))
        self.actionErrorZoom_in_2.setShortcut(_translate("MainWindow", "Ctrl+="))
        self.actionErrorZoom_out_2.setText(_translate("MainWindow", "Zoom out"))
        self.actionErrorZoom_out_2.setShortcut(_translate("MainWindow", "Ctrl+-"))

        #buttons connections 
        self.actionOpen_File.triggered.connect(lambda: self.openFile())
        self.actionCurveZoom_in.triggered.connect(lambda: self.zoomIn(0))
        self.actionErrorZoom_in_2.triggered.connect(lambda: self.zoomIn(1))
        self.actioncurveZoom_out.triggered.connect(lambda: self.zoomOut(0))
        self.actionErrorZoom_out_2.triggered.connect(lambda: self.zoomOut(1))
        self.OneChunkRadioButton.toggled.connect(lambda: self.NumberChunksSpinBoxDisable())
        self.MultipleChunksRadioButton.toggled.connect(lambda: self.NumberChunksSpinBoxEnable())
        self.NumberChunksSpinBox.valueChanged.connect(lambda: self.SetNumChunks(self.NumberChunksSpinBox.value()))
        self.xAxisInterpolationRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("X","Inter"))
        self.xAxisNumChunksRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("X","Chunks"))
        self.yAxisInterpolationRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("Y","Inter"))
        self.yAxisNumChunksRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("Y","Chunks"))
        self.xAxisOverLapRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("X","Over"))
        self.yAxisOverLapRadioBtn.toggled.connect(lambda: self.ErrorOptionsEnabling("Y","Over"))
        
        self.actionExit.triggered.connect(lambda: self.exit())
        self.InterPolationOrderSlider.valueChanged.connect(lambda: self.InterpolationOrdersetting(self.InterPolationOrderSlider.value()) )
        #self.InterPolationOrderSlider.valueChanged.connect(lambda : self.interpolationPrep())
        self.ExtrapolationEfficiencySlider.valueChanged.connect(lambda: self.ExtrapolationCoefEdit(self.ExtrapolationEfficiencySlider.value()))
        self.LinearInterpRadioBtn.toggled.connect(lambda: self.interpolationPrep(0))
        self.PolynomialInterpRadioBtn.toggled.connect(lambda : self.interpolationPrep(1))
        self.ChunkNumberComboBox.currentIndexChanged.connect(lambda : self.setChunkOrder())
        self.ErrorMappingButton.clicked.connect(lambda: self.errorMappingClicked())
        self.actionSave_Curve_fitting_IMG.triggered.connect(lambda: self.saveCurveFitting())
        

        #golbal varaibles of constants declaration
        self.feature=0
        self.target=0
        self.ampArray=0
        self.signalYMin=0
        self.signalYMax=0
        self.signalXmin=0
        self.signalXmax=0
        self.numChunks=1  
        self.overLappingTimes=6     
        self.Chunkorder=0
        self.polyVectors = np.array([])
        self.axis=""
        self.type=""
        self.errorMappingClickedTime=0
        #setting order default to 1
        self.InterpolationOrder=self.InterPolationOrderSlider.value()
        self.lcdOrder.display(self.InterpolationOrder)
        self.interpolationTypeFlag=-1
        self.errorComboBoxFlag = 0
        self.ErrorMapXaxis=""
        self.ErrorMapYaxis=""
        self.result=[]
        self.logHistory=[]

        #diasbling the num spinbox by default to avoid errors
        self.NumberChunksSpinBox.setDisabled(True)
        #changing LCD color
        self.lcdOrder.setStyleSheet('background-color:black')
        #setting extrapolation coeff to 100% by default
        self.ExtrapolationCoef=100
        self.errorMappingProg=1


    def saveCurveFitting(self):
        exporterFitting= pyqtgraph.exporters.ImageExporter(self.CurveFittingGraph.scene())
        exporterFitting.export('curveFitting.png') 
        self.logHistory.append("The user clicked on the save curve fit graph as an image and saved it under the name curveFitting.png")

    def openFile(self):
        """Opens the chosen file from local machine"""
        #try:
        self.file_path=QFileDialog.getOpenFileName()[0]
        self.read_data(self.file_path)
        self.logHistory.append("The user opened a file")

        #except ParserError:
         #   print("please choose a csv file")
            
     
    def read_data(self,file_name):
        """loads the data from chosen file"""
        self.CurveFittingGraph.clear()
        self.MathDisplayArea.setRowCount(0)
        dataFile=pd.read_csv(r"{}".format(file_name))
        self.label1=file_name
        self.feature=list(pd.to_numeric(dataFile.iloc[:,0],downcast="float"))
        self.target=list(pd.to_numeric(dataFile.iloc[:,-1],downcast="float"))
        self.signalYMin=min(self.target)
        self.signalYMax=max(self.target)
        self.signalXMin=min(self.feature)
        self.signalXMax=max(self.feature)
        self.settingCurveLimits()
        self.logHistory.append("The GUI read the data from the file that was opened")
        self.draw(self.feature,self.target)

    def settingCurveLimits(self):
        self.CurveFittingGraph.setLimits(xMin=self.signalXMin)
        self.CurveFittingGraph.setLimits(yMin=self.signalYMin)
        self.CurveFittingGraph.setLimits(yMax=self.signalYMax)
        self.logHistory.append("The curve fitting graphing area's X-axis and Y-axis limits were set")


    def setChunkOrder(self):
        self.Chunkorder= int(self.ChunkNumberComboBox.currentIndex())+1
        if( self.PolynomialInterpRadioBtn.isChecked() or self.LinearInterpRadioBtn.isChecked):
            if(self.interpolationTypeFlag ==0):
                self.linearInterpolate()
            elif(self.interpolationTypeFlag ==1):
                self.polyInterpolate()
            else:
                print("Please choose an interpolation type from the radio buttons")
        else:
            pass
        self.logHistory.append("The chunk order was chosen from the combobox")



    def draw(self,feature,target):
        """sets up our canvas to plot"""
        self.index=0 
        self.CurveFittingGraph.plot(self.feature[0:1000], self.target[0:1000], pen="red")

        try:
          self.InterpolationOrdersetting()
          self.ChunkNumberComboBox()
          self.ChooseChunkComboBox()
        except:
            pass
        self.logHistory.append("The Draw function was called")

        
    def zoomIn(self, val):
        self.CurveFittingGraph.getViewBox().scaleBy((0.5,0.5))
        self.logHistory.append("The user choose to zoom in on the curve fitting graphing area")
        
    
    def zoomOut(self,val):
        self.CurveFittingGraph.getViewBox().scaleBy((2,2))
        self.logHistory.append("The user choose to zoom out on the curve fitting graphing area")

    def errorMappingClicked(self):
        self.errorMappingClickedTime=self.errorMappingClickedTime+1
        if self.errorMappingClickedTime % 2 != 0:
            self.logHistory.append("The Error mapping run button was clicked")
            self.ErrorMappingButton.setText("Stop EM")
            self.errCalc(1)
        elif self.errorMappingClickedTime %2 ==0:
            self.logHistory.append("The Error mapping stop button was clicked")
            self.ErrorMappingButton.setText("Run EM")
            self.errCalc(0)
            self.ErrorMappingProgressBar.setValue(0)
        
    

    def errorMap(self, errorVals):
        self.arr=[]
        if(self.ErrorMapXaxis=="Chunks" and self.ErrorMapYaxis=="Inter"):
            x=self.numChunks
            y=self.InterpolationOrder
        elif(self.ErrorMapYaxis=="Chunks" and self.ErrorMapXaxis=="Inter"):
            y=self.numChunks
            x=self.InterpolationOrder
        elif(self.ErrorMapXaxis=="Over" and self.ErrorMapYaxis=="Chunks"):
            x=6
            y=self.numChunks
        elif(self.ErrorMapYaxis=="Over" and self.ErrorMapXaxis=="Chunks"):
            y=6
            x=self.numChunks
        elif(self.ErrorMapXaxis=="Over" and self.ErrorMapYaxis=="Inter"):
            x=6
            y=self.InterpolationOrder
        elif(self.ErrorMapYaxis=="Over" and self.ErrorMapYaxis=="Inter"):
            y=6
            x=self.InterpolationOrder
        self.logHistory.append("The Radio buttons determining which axes hold which values in the error map were checked")
        

 

        lis = [j for j in range(0, int(x))]
        lisx = [i for i in range(0, int(y))]
        print(errorVals)
        err = reshape(errorVals, (len(lisx), len(lis)))
        
        

        plt.imshow(err, cmap='inferno', interpolation='none',aspect='auto')
        self.logHistory.append("The error map was generated")

        plt.colorbar()
        plt.xlabel(x)
        plt.ylabel(y)
        plt.savefig('../fig.png')
        plt.show()
        plt.close()
        self.ErrorMappingGraph.setMaximumHeight(300)
        self.ErrorMappingGraph.setMaximumWidth(400)
        self.ErrorMappingGraph.setPixmap(QPixmap(u"../fig.png"))
        self.ErrorMappingGraph.setScaledContents(True)
        

    def errCalc(self, en):
        self.logHistory.append("The errCalc function was called, begining of error calculations")
        if en == 1:
            self.errArr=[]
            if self.ErrorMapXaxis == "Chunks" and self.ErrorMapYaxis == "Inter":
                if self.interpolationTypeFlag == 0 and self.numChunks ==1:
                    self.result=numpy.linalg.norm(self.target)-numpy.linalg.norm(self.y_axis)/numpy.linalg.norm(self.target)
                    self.errArr.append(self.result)      
                elif self.interpolationTypeFlag ==0 and self.numChunks >1 :
                    
                    self.fixedOverLapValue=int((int(self.ChooseOverLapComboBox.currentText())/100) * len(self.x_axis))
                    #print(self.fixedOverLapValue)
                    for i in range(1,self.numChunks+1,1):
                        
                        for j in range (self.InterPolationOrderSlider.value()):
                                #self.result=numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*i:self.fixedOverLapValue+ len(self.x_axis)*(i+1) if i < self.numChunks else 1000])-numpy.linalg.norm(self.y_axis[self.fixedOverLapValue+ len(self.x_axis)*i:self.fixedOverLapValue+ len(self.x_axis)*(i+1) if i < self.numChunks else 1000])/numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*i:self.fixedOverLapValue+ len(self.x_axis)*(i+1) if i < self.numChunks else 1000])
                                #print(self.result)
                                coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1]  ,deg=1)
                                self.polyVectors = coeff
                                polynomial= np.poly1d(coeff)
                                self.targetError=self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                                self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                                self.result=numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks+1 else 1000])-numpy.linalg.norm(self.y_axis[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                                self.errArr.append(self.result)
                                self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                                self.errorMappingProg+=1
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()
                    self.errorMappingClicked()
                elif self.interpolationTypeFlag == 1 and self.numChunks ==1:
                   
                    self.result=numpy.linalg.norm(self.target)-numpy.linalg.norm(self.y_axis)/numpy.linalg.norm(self.target)
                    self.errArr.append(self.result)
                elif self.interpolationTypeFlag == 1 and self.numChunks >1 :
                    self.fixedOverLapValue=int((int(self.ChooseOverLapComboBox.currentText())/100) * len(self.x_axis))
                    for i in range (1,self.numChunks+1,1):
                        for j in range (self.InterPolationOrderSlider.value()):

                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = self.InterpolationOrder)
                            polynomial= np.poly1d(coeff) 
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks+1 else 1000])-numpy.linalg.norm(self.y_axis[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

            elif self.ErrorMapXaxis == "Inter" and self.ErrorMapYaxis == "Chunks":
                if self.interpolationTypeFlag == 0 and self.numChunks ==1:
                    self.result=numpy.linalg.norm(self.target)-numpy.linalg.norm(self.y_axis)/numpy.linalg.norm(self.target)
                    self.errArr.append(self.result)
                elif self.interpolationTypeFlag ==0 and self.numChunks > 1:
                    self.fixedOverLapValue=int((int(self.ChooseOverLapComboBox.currentText())/100) * len(self.x_axis))
              
                    #self.result=numpy.linalg.norm(self.target)-numpy.linalg.norm(self.y_axis)/numpy.linalg.norm(self.target)
                    #print(self.result)
                    for i in range (1,self.InterPolationOrderSlider.value()+1,1):
                        for j in range (self.numChunks):
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = 1)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks+1 else 1000])-numpy.linalg.norm(self.y_axis[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()
                elif self.interpolationTypeFlag ==1 and self.numChunks ==1 :
                    self.result=numpy.linalg.norm(self.target)-numpy.linalg.norm(self.y_axis)/numpy.linalg.norm(self.target)
                    self.errArr.append(self.result)
                elif self.interpolationTypeFlag ==1 and self.numChunks >1 :
                    self.fixedOverLapValue=int((int(self.ChooseOverLapComboBox.currentText())/100) * len(self.x_axis))
                    for i in range (1,self.InterPolationOrderSlider.value()+1,1):
                        for j in range (self.numChunks):
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = self.InterpolationOrder)
                            polynomial= np.poly1d(coeff) 
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            #self.result=numpy.linalg.norm(self.targetError)-numpy.linalg.norm(self.y_axisError)/numpy.linalg.norm(self.targetError)
                            self.result=numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks+1 else 1000])-numpy.linalg.norm(self.y_axis[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.fixedOverLapValue+ len(self.x_axis)*(i-1):self.fixedOverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

            elif self.ErrorMapXaxis == "Over" and self.ErrorMapYaxis == "Chunks":
                if self.interpolationTypeFlag==0:
                    self.fixedOrderValue=self.ChooseOrderComboBox.currentIndex()+1
                    #self.fixedOverLapValue=int((int(self.ChooseOverLapComboBox.currentText())/100) * len(self.x_axis))
                    self.OverLapConst=0
                    for i in range (6):
                        for j in range(1,self.numChunks+1,1):
                            
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1 ] , self.target[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1] ,deg = 1)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()
                
                elif self.interpolationTypeFlag == 1:
                    self.fixedOrderValue=self.ChooseOrderComboBox.currentIndex()+1
                    self.OverLapConst=0
                    for i in range(6):
                        for j in range(1,self.numChunks+1,1):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1 ] , self.target[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1] ,deg = self.fixedOrderValue)
                            self.polyVectors = coeff
                            polynomial= np.poly1d(coeff) 
                            self.targetError=self.target[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            #self.result=numpy.linalg.norm(self.targetError)-numpy.linalg.norm(self.y_axisError)/numpy.linalg.norm(self.targetError)
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                    
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

            elif self.ErrorMapXaxis == "Chunks" and self.ErrorMapYaxis == "Over":
                if self.interpolationTypeFlag == 0:
                    self.fixedOrderValue= self.ChooseOrderComboBox.currentIndex()+1
                    self.OverLapConst=0
                    for i in range (1,self.numChunks+1,1):
                        for j in range (6):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = 1)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                    
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

                elif self.interpolationTypeFlag == 1:
                    self.fixedOrderValue= self.ChooseOrderComboBox.currentIndex()+1
                    self.OverLapConst=0
                    for i in range (1,self.numChunks+1,1):
                        for j in range (6):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = self.fixedOrderValue)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

            elif self.ErrorMapXaxis == "Over" and self.ErrorMapYaxis == "Inter":
                if self.interpolationTypeFlag == 0:
                    self.fixedChunkValue= self.ChooseChunkComboBox.currentIndex()+1
                    self.OverLapConst =0 
                    for i in range (6):
                        for j in range(1,self.InterPolationOrderSlider.value()+1,1):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1 ] , self.target[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1] ,deg = 1)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()
                
                elif self.interpolationTypeFlag == 1:
                    self.fixedChunkValue= self.ChooseChunkComboBox.currentIndex()+1
                    self.OverLapConst =0 
                    for i in range (6):
                        for j in range(1,self.InterPolationOrderSlider.value()+1,1):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1 ] , self.target[(j-1)*int(self.maxLength/self.numChunks) : (j*int(self.maxLength/self.numChunks))-1] ,deg = j)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(j-1)*int(self.maxLength/self.numChunks):(j-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(j-1):self.OverLapValue+ len(self.x_axis)*j if j < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()


            elif self.ErrorMapXaxis == "Inter" and self.ErrorMapYaxis == "Over":
                if self.interpolationTypeFlag == 0:
                    self.fixedChunkValue= self.ChooseChunkComboBox.currentIndex()+1
                    self.OverLapConst =0 
                    for i in range(1,self.InterPolationOrderSlider.value()+1,1):
                        for j in range (6):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = 1)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()

                elif self.interpolationTypeFlag == 1:
                    self.fixedChunkValue =self.ChooseChunkComboBox.currentIndex()+1
                    self.OverLapConst =0
                    for i in range(1,self.InterPolationOrderSlider.value()+1,1):
                        for j in range (6):
                            self.OverLapValue=int((self.OverLapConst/100) * len(self.x_axis))
                            coeff=np.polyfit(self.feature[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1 ] , self.target[(i-1)*int(self.maxLength/self.numChunks) : (i*int(self.maxLength/self.numChunks))-1] ,deg = i)
                            polynomial= np.poly1d(coeff)
                            self.targetError=self.target[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)]
                            self.y_axisError=polynomial(self.feature[(i-1)*int(self.maxLength/self.numChunks):(i-1)*int(self.maxLength/self.numChunks)+int(self.maxLength/self.numChunks)])
                            self.result=numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])-numpy.linalg.norm(self.y_axis[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])/numpy.linalg.norm(self.target[self.OverLapValue+ len(self.x_axis)*(i-1):self.OverLapValue+ len(self.x_axis)*i if i < self.numChunks-1 else 1000])
                            self.errArr.append(self.result)
                            self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                            self.errorMappingProg+=1
                        self.OverLapConst=self.OverLapConst+5
                    if 100-self.errorMappingProg> 0:
                        self.ErrorMappingProgressBar.setValue(100-self.errorMappingProg)
                    self.errorMappingProg=0
                    sleep(1)
                    self.ErrorMappingProgressBar.setValue(self.errorMappingProg)
                    self.errorMappingClicked()
            self.errorMap(self.errArr)     
            self.logHistory.append("End of error calculations")   
        #collapsing the error mapping area when shutting    
        elif en==0:
            self.logHistory.append("Collapsing the error area")
            self.ErrorMappingGraph.setMaximumHeight(0)
            self.ErrorMappingProgressBar.setValue(0)



     

    def NumberChunksSpinBoxDisable(self):
        self.NumberChunksSpinBox.setDisabled(True)
        self.numChunks=1
        self.ChooseOverLapComboBox.clear()
        self.xAxisOverLapRadioBtn.setDisabled(True)
        self.yAxisOverLapRadioBtn.setDisabled(True)
        self.ChunkNumberComboBoxEdit()
        self.ErrorOptionsEnabling(self.axis,self.type)
        self.MathDisplayArea.setRowCount(self.numChunks)
        self.logHistory.append("The number of chunks were determined by the user and stored in the corresponding combobox")


    def NumberChunksSpinBoxEnable(self):
        self.NumberChunksSpinBox.setDisabled(False)

    def SetNumChunks(self,val):
        self.numChunks=val
        
        self.MathDisplayArea.setRowCount(self.numChunks)
        self.ChunkNumberComboBoxEdit()
        self.ErrorOptionsEnabling(self.axis,self.type)


    def ErrorOptionsEnabling(self, axis, type):
        self.axis=axis
        self.type=type
        
        if axis=="X":
            if type =="Inter":
                self.yAxisInterpolationRadioBtn.setDisabled(True)
                self.yAxisNumChunksRadioBtn.setDisabled(False)
                self.yAxisOverLapRadioBtn.setDisabled(False)
                self.ErrorMapXaxis="Inter"
            elif type == "Chunks":
                self.yAxisNumChunksRadioBtn.setDisabled(True)
                self.yAxisInterpolationRadioBtn.setDisabled(False)
                self.yAxisOverLapRadioBtn.setDisabled(False)
                self.ErrorMapXaxis="Chunks"
                #self.ErrorMapYaxis="Inter"
                #self.ErrorMappingGraph.setRowCount(self.numChunks)
                #self.ErrorMappingGraph.setColumnCount(self.InterPolationOrderSlider.value())
            else:
                self.yAxisOverLapRadioBtn.setDisabled(True)
                self.yAxisInterpolationRadioBtn.setDisabled(False)
                self.yAxisNumChunksRadioBtn.setDisabled(False)
                self.ErrorMapXaxis="Over"
                #self.ErrorMappingGraph.setRowCount(self.overLappingTimes)
        elif axis=="Y":
            if type =="Inter":
                self.xAxisInterpolationRadioBtn.setDisabled(True)
                self.xAxisNumChunksRadioBtn.setDisabled(False)
                self.xAxisOverLapRadioBtn.setDisabled(False)
                #self.ErrorMapXaxis="Chunks"
                self.ErrorMapYaxis="Inter"
          

            elif type =="Chunks":
                self.xAxisNumChunksRadioBtn.setDisabled(True)
                self.xAxisInterpolationRadioBtn.setDisabled(False)
                self.xAxisOverLapRadioBtn.setDisabled(False)
                #self.ErrorMapYaxis="Chunks"
                self.ErrorMapYaxis="Chunks"
            

            else:
                self.xAxisOverLapRadioBtn.setDisabled(True)
                self.xAxisInterpolationRadioBtn.setDisabled(False)
                self.xAxisNumChunksRadioBtn.setDisabled(False)
                self.ErrorMapYaxis="Over"
                #self.ErrorMappingGraph.setColumnCount(self.overLappingTimes)

        if self.numChunks >1 and self.errorComboBoxFlag == 0:
            self.xAxisOverLapRadioBtn.setDisabled(False)
            self.yAxisOverLapRadioBtn.setDisabled(False)
            for i in range (0,30,5):
                self.ChooseOverLapComboBox.addItem(str(i))
            self.errorComboBoxFlag=1
        
        

    def ChunkNumberComboBoxEdit(self):
        self.ChooseChunkComboBox.clear()
        self.ChunkNumberComboBox.clear()
        
        for i in np.arange(1,self.numChunks+1):
            self.ChunkNumberComboBox.addItem(str("Chunk # " +str(i)))
            self.ChooseChunkComboBox.addItem(str("Chunk # " +str(i)))
        

        self.ErrorOptionsEnabling(self.axis,self.type)

    
    def ChooseOrderComboBoxEdit(self):
        self.ChooseOrderComboBox.clear()
        self.lcdOrder.display(self.InterpolationOrder)
        for j in np.arange(1,self.InterpolationOrder+1):
            self.ChooseOrderComboBox.addItem(str("Order # " +str(j)))

        self.ErrorOptionsEnabling(self.axis,self.type)
        self.logHistory.append("The desired order was chosen ")

    
    def interpolationPrep(self, val):
        self.logHistory.append("The interpolationPrep function was called")
        if val == 0:
            self.interpolationTypeFlag =0
            self.linearInterpolate()
        elif val ==1:
            self.interpolationTypeFlag =1
            self.polyInterpolate()
        else:
            print("Choose an intrpolation type from the radio buttons")

    def linearInterpolate(self):
        self.logHistory.append("Linear interpolation was called")
        if self.ExtrapolationCoef ==0:
            print("Please check the extrapolation slider as there mush be an error in its code lines")
        else:
            self.maxLength=int(self.ExtrapolationCoef* 1000 *0.01)
                    
            self.perform_interpolation(1)
            self.linear_latex_equation(self.coeffs)
            self.write_error(self.residuals)
            self.ExtrapolationFunc(self.coeffs[self.Chunkorder-1])   
    
    def polyInterpolate(self):
        self.logHistory.append("Polynomial interpolation was called")
        if self.ExtrapolationCoef ==0:
            print("Please check the extrapolation slider as there mush be an error in its code lines")
        else:
            self.maxLength=int(self.ExtrapolationCoef* 1000 *0.01)
            self.perform_interpolation(self.InterpolationOrder)
            self.polynomial_latex_equation(self.coeffs)
            self.write_error(self.residuals)
            self.ExtrapolationFunc(self.coeffs[self.Chunkorder-1])

    
    def ExtrapolationFunc(self, coeff):
        self.logHistory.append("Extrapolation was called")
        if self.numChunks != 1:
            pass
        else:
            if self.ExtrapolationCoef ==100:
                pass
            elif self.ExtrapolationCoef <100:
                polynomial= np.poly1d(coeff)
                print(int((1000*0.01*self.ExtrapolationCoef)))
                self.x_axis=self.feature[int((1000*0.01*self.ExtrapolationCoef)+5):5000]
                self.y_axis=polynomial(self.feature[int((1000*0.01*self.ExtrapolationCoef)+5):5000])
                self.extrapolated_curve = self.CurveFittingGraph.plot(self.x_axis,self.y_axis, pen=None , symbol = '+')
 


    
    def InterpolationOrdersetting(self, val):
        self.logHistory.append("Interpolation order setting was made")
        self.InterpolationOrder=val
        self.ChooseOrderComboBoxEdit()
        if self.interpolationTypeFlag ==1:
            self.polyInterpolate()
        else:
            self.interpolationPrep(0)

    
    def ExtrapolationCoefEdit(self, val):
        self.logHistory.append("The extrapolation slider value was changed and thus the extrapolation coefficient ")
        self.ExtrapolationCoef=val*10
        print(self.ExtrapolationCoef)
        self.interpolationPrep(self.interpolationTypeFlag)
        
    
    def exit(self):
        self.logHistory.append("End of session")
        self.logging()
        sys.exit()


    def linear_latex_equation(self,coeffs):
        self.logHistory.append("Latex equation is called")
        """writes latex equation for a linear interpolation"""
        #getting signed and rounded coeffecients
        coeff=coeffs[self.Chunkorder-1]
        coeff=list(coeff)
        for i in range(0,len(coeff)):
            coeff[i]=round(coeff[i],3)
            if (coeff[i]>=0):
                coeff[i]="+"+str(coeff[i])
 
        label=self.mathTex_to_QPixmap(r'{} x {}'.format(coeff[0],coeff[1]))
        self.MathDisplayArea.setCellWidget(self.Chunkorder-1,0,label)
        self.adjust_table()

    
    def polynomial_latex_equation(self,coeffs):
        """writes latex equation for a polynomial interpolation"""
        
        #getting signed and rounded coeffecients
        coeff=coeffs[self.Chunkorder-1]
        
        coeff=list(coeff)
        for i in range(0,len(coeff)):
            coeff[i]=round(coeff[i],3)
            if (coeff[i]>=0):
                coeff[i]="+"+str(coeff[i])
   
        eq=r'{}'.format(coeff[0])+r'x^{%s}'%self.InterpolationOrder
        for i in range(self.InterpolationOrder-1,1,-1):
            eq+=r'{}'.format(coeff[self.InterpolationOrder-i])+r'x^{%s}'%i
        eq+=r'{}'.format(coeff[-2])+r'x{%s}'%coeff[-1]         
        
        label=self.mathTex_to_QPixmap(eq)
        self.MathDisplayArea.setCellWidget(self.Chunkorder-1,0,label)
        self.adjust_table() 
        

    
    
    def adjust_table(self):
        """adjusts size of rows and columns according to content"""
        self.MathDisplayArea.resizeRowsToContents()        
        self.MathDisplayArea.resizeColumnsToContents()	    
    
    def mathTex_to_QPixmap(self,mathTex):
     """converts equation into a pixmap and puts it on a label widget"""
    # set up a mpl figure instance
     fig = mpl.figure.Figure()
     fig.patch.set_facecolor('none')
     fig.set_canvas(FigureCanvasAgg(fig))
     renderer = fig.canvas.get_renderer()

    #plot the mathTex expression
     ax = fig.add_axes([0, 0, 1, 1])
     ax.axis('off')
     ax.patch.set_facecolor('none')
   #  t = ax.text(0, 0, r"$%s$" %(mathTex), ha='left', va='bottom', fontsize=15,color='blue')
     t = ax.text(0, 0, r"$%s$" %(mathTex), ha='left', va='bottom', fontsize=15,color='blue')

    #fit figure size 
     fwidth, fheight = fig.get_size_inches()
     fig_bbox = fig.get_window_extent(renderer)
     text_bbox = t.get_window_extent(renderer)
     tight_fwidth = text_bbox.width * fwidth / fig_bbox.width
     tight_fheight = text_bbox.height * fheight / fig_bbox.height
     fig.set_size_inches(tight_fwidth, tight_fheight)

    #convert mpl figure to QPixmap and put it on a label widget
     buf, size = fig.canvas.print_to_buffer()
     qimage = QtGui.QImage.rgbSwapped(QtGui.QImage(buf, size[0], size[1],QtGui.QImage.Format_ARGB32))
     qpixmap = QtGui.QPixmap(qimage)
     label = QtWidgets.QLabel()
     label.setPixmap(qpixmap)
     return label

    

    def write_error(self,residual):
        """writes the error of interpolation in table"""
        try:
            error=cmath.sqrt(residual[0])
            error=round(error.real,3)
        except:
            error=0.0
        self.MathDisplayArea.setItem(self.Chunkorder-1,1,QTableWidgetItem(str(error)))        
        self.adjust_table()
        pass



    def split_into_chunks(self):
        self.logHistory.append("Splitting the dataset into chunks")
        """splits the original data into the chosen number of chunks"""
        self.feature_chunks=np.array_split(self.feature[0:1000],self.numChunks)
        self.target_chunks=np.array_split(self.target[0:1000],self.numChunks)
        
    def perform_interpolation(self,degree):
        self.logHistory.append("Performing interpolation")
        """plots the interpolation of each chunk"""
        self.coeffs=[]
        self.residuals=[]
        self.calculated_chunks=[]

        self.CurveFittingGraph.clear()
        self.CurveFittingGraph.plot(self.feature[0:1000], self.target[0:1000], pen="red")
       
        self.split_into_chunks()     
        for i in range(len(self.feature_chunks)):
            coeff,residual,a,b,c=np.polyfit(self.feature_chunks[i] , self.target_chunks[i] ,deg =degree,full=True)
            self.coeffs.append(coeff)
            self.residuals.append(residual)
            polynomial= np.poly1d(coeff)
            self.CurveFittingGraph.plot(self.feature_chunks[i],polynomial(self.feature_chunks[i]),pen='blue',symbol='o')        
            self.x_axis=self.feature_chunks[i]
            self.y_axis=polynomial(self.feature_chunks[i])
        k=0

    def logging(self):
        f=open("Task4Log.txt","w+")
        for i in self.logHistory:
            f.write("=> %s\r\n" %(i))
        f.close()
        

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())